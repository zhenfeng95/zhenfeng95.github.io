



<!DOCTYPE html>
<html lang="zh-CN" class="with-v3-banner">
  <head>
    <title>网站上线部署流程 — zzf的个人博客笔记</title>
    <meta charset="utf-8">
    <meta name="description" content="Vue.js - The Progressive JavaScript Framework">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="alternate" hreflang="x-default" href="https://v2.vuejs.org/website/process/index.html">
    <link rel="alternate" hreflang="zh" href="https://v2.cn.vuejs.org/website/process/index.html">
    <link rel="alternate" hreflang="ja" href="https://jp.vuejs.org/website/process/index.html">
    <link rel="alternate" hreflang="ru" href="https://ru.vuejs.org/website/process/index.html">
    <link rel="alternate" hreflang="ko" href="https://kr.vuejs.org/website/process/index.html">
    <link rel="alternate" hreflang="pt-BR" href="https://br.vuejs.org/website/process/index.html">
    <link rel="alternate" hreflang="fr" href="https://fr.vuejs.org/website/process/index.html">
    <link rel="alternate" hreflang="es" href="https://es.vuejs.org/website/process/index.html">

    <meta property="og:type" content="article">
    <meta property="og:title" content="网站上线部署流程 — Vue.js">
    <meta property="og:description" content="Vue.js - The Progressive JavaScript Framework">
    <meta property="og:image" content="https://v2.cn.vuejs.org/images/logo.png">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="网站上线部署流程 — Vue.js">
    <meta name="twitter:description" content="Vue.js - The Progressive JavaScript Framework">
    <meta name="twitter:image" content="https://v2.cn.vuejs.org/images/logo.png">

    <!-- <link rel="apple-touch-icon" sizes="57x57" href="/images/icons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/images/icons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/icons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/icons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/icons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/icons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/icons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/icons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/icons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/images/icons/android-icon-192x192.png"> -->
    <!-- <link rel="icon" type="image/png" sizes="32x32" href="/images/icons/favicon-32x32.png"> -->
    <link rel="icon" type="image/png" sizes="96x96" href="/images/icons/favicon.png">
    <!-- <link rel="icon" type="image/png" sizes="16x16" href="/images/icons/favicon-16x16.png"> -->
    <meta name="msapplication-TileImage" content="/images/icons/ms-icon-144x144.png">
    <!-- <link rel="icon" href="/images/logo.svg"> -->

    <meta name="msapplication-TileColor" content="#4fc08d">
    <meta name="theme-color" content="#4fc08d">

    <meta name="msapplication-config" content="browserconfig.xml">
    <link rel="manifest" href="/manifest.json">

    <!-- <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin> -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com" rel="preconnect" crossorigin> -->

    <!-- <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono&display=swap" rel="stylesheet"> -->
    <!-- <link href="https://fonts.googleapis.com/css?family=Dosis:500&text=Vue.js&display=swap" rel="stylesheet"> -->

    <link href="//code.bdstatic.com/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">

    <!-- main page styles -->
    
<link rel="stylesheet" href="/css/page.css">


    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="/js/vue.js"></script>

    

    <script>
      Vue.config.productionTip = false
      window.PAGE_TYPE = "process"
    </script>

    <!-- Fathom - beautiful, simple website analytics -->
    <script src="https://cdn.usefathom.com/script.js" data-site="KTDIHEIJ" defer></script>
    <!-- / Fathom -->

    <!-- vimeo analytics -->
    <!-- <script type="text/javascript" defer="defer" src="https://extend.vimeocdn.com/ga/72160148.js"></script> -->
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Vue123.js" type="application/atom+xml">
</head>
  <body class="docs">

    

    <div id="mobile-bar" >
      <a class="menu-button"></a>
      <a class="logo" href="/"></a>
    </div>
    <div>


  <header id="header">
    <a id="logo" href="/">
      <!-- <img src="/images/logo.svg" alt="vue logo"> -->
      <span>个人博客</span>
    </a>
    <ul id="nav">
      <li>
    <form id="search-form">
        <input type="text" id="search-query-nav" class="search-query st-default-search-input" aria-label="搜索" />
    </form>
</li>
<li class="nav-dropdown-container learn">
    <a class="nav-link">前端基础</a
    ><span class="arrow"></span>
    <ul class="nav-dropdown">
        <li><h4>文档</h4></li>
        <li>
            <ul>
                <li><a href="/v2/guide/" class="nav-link">HTML</a></li>
        <li><a href="/v2/api/" class="nav-link">CSS</a></li>
        <li><a href="/v2/style-guide/" class="nav-link">JS</a></li>
            </ul>
        </li>
    </ul>
</li>
 <li class="nav-dropdown-container framework">
    <a class="nav-link">前端框架</a
    ><span class="arrow"></span>
    <ul class="nav-dropdown">
        <li>
            <ul>
                 <li><a href="/framework/vue/" class="nav-link">vue</a></li>
                  <li><a href="/framework/uniapp/" class="nav-link">uniapp</a></li>
               
            </ul>
        </li>
    </ul>
</li>
 <li class="nav-dropdown-container resources">
    <a class="nav-link current">网站部署</a
    ><span class="arrow"></span>
    <ul class="nav-dropdown">
        <li>
            <ul>
                 <li><a href="/website/process/" class="nav-link current">部署流程</a></li>
                <li><a href="/website/hexo/" class="nav-link">HEXO</a></li>
                <li><a href="/website/docker/" class="nav-link">Docker</a></li>
            </ul>
        </li>
    </ul>
</li>
 <li class="nav-dropdown-container tool">
    <a class="nav-link">工具</a
    ><span class="arrow"></span>
    <ul class="nav-dropdown">
        <li>
            <ul>
                 <li><a href="/tool/environment/" class="nav-link">开发环境</a></li>
                 <li><a href="/tool/git/" class="nav-link">git</a></li>
                  <li><a href="/tool/webpack/" class="nav-link">webpack</a></li>
                <li><a href="/tool/jenkins/" class="nav-link">jenkins</a></li>
            </ul>
        </li>
    </ul>
</li>
 <li class="nav-dropdown-container backend">
    <a class="nav-link">服务端</a
    ><span class="arrow"></span>
    <ul class="nav-dropdown">
        <li>
            <ul>
                 <li><a href="/backend/node/" class="nav-link">node</a></li>
                 <li><a href="/backend/MongoDB/" class="nav-link">MongoDB</a></li>
                 
            </ul>
        </li>
    </ul>
</li>

<!-- <li>
    <a href="/eol/" class="badge-parent">终止支持 (EOL)<sup class="badge">新</sup></a>
</li> -->

    </ul>
  </header>
</div>

    
      <div id="main" class="fix-sidebar">
         

<div class="sidebar">
    <div class="sidebar-inner">
        
        <div class="list"> <ul class="menu-root">
  
    
    
    <li>
      <a href="/website/process/index.html" class="sidebar-link current">网站上线部署流程</a>
    </li>
  
</ul>
 </div>
    </div>
</div>
<!--

<div id="sidebar-sponsors-platinum-right">
  <div class="main-sponsor">
    <span>白金赞助商</span>
    <div>
    <a href="https://www.vuemastery.com/" target="_blank" rel="sponsored noopener" class="logo">
      <img src="https://sponsors.vuejs.org/images/vuemastery.png" alt="VueMastery">
    </a>
    <a href="https://vehikl.com/" target="_blank" rel="sponsored noopener" class="logo">
      <img src="https://sponsors.vuejs.org/images/vehikl.png" alt="Vehikl">
    </a>
    <a href="https://vuejs.amsterdam/" target="_blank" rel="sponsored noopener" class="logo">
      <img src="https://sponsors.vuejs.org/images/vue_js_amsterdam.png" alt="Vue.js Amsterdam">
    </a>
    <a href="https://www.storyblok.com" target="_blank" rel="sponsored noopener" class="logo">
      <img src="https://sponsors.vuejs.org/images/storyblok.png" alt="Storyblok">
    </a>
    <a href="https://opencollective.com/2021-frameworks-fund" target="_blank" rel="sponsored noopener" class="logo">
      <img src="https://sponsors.vuejs.org/images/chrome_frameworks_fund.png" alt="Chrome Frameworks Fund">
    </a>
    <a href="https://www.herodevs.com/support/vue" target="_blank" rel="sponsored noopener" class="logo">
      <img src="https://sponsors.vuejs.org/images/herodevs.png" alt="HeroDevs">
    </a>
    <a href="https://certificates.dev/javascript/?ref=vuejs-sponsor&friend=VUEJS" target="_blank" rel="sponsored noopener" class="logo">
      <img src="https://sponsors.vuejs.org/images/javascript_certification.png?v2" alt="JavaScript Certification">
    </a>
    <a href="https://www.coderabbit.ai?utm_source=github&utm_medium=sponsors&utm_campaign=evan_you_2025" target="_blank" rel="sponsored noopener" class="logo">
      <img src="https://sponsors.vuejs.org/images/coderabbit_.png" alt="CodeRabbit ">
    </a>
    <a href="https://imagekit.io/?utm_source=vuejs&utm_medium=referral&utm_campaign=oss-sponsorship&utm_content=homepage" target="_blank" rel="sponsored noopener" class="logo">
      <img src="https://sponsors.vuejs.org/images/imagekit_io.svg" alt="ImageKit.io">
    </a>
    <a href="https://www.greptile.com/?utm_source=vuejs&utm_medium=sponsorship&utm_campaign=vue_sponsor_page" target="_blank" rel="sponsored noopener" class="logo">
      <img src="https://sponsors.vuejs.org/images/greptile.png" alt="Greptile">
    </a>
    </div>
  </div>
  <a class="become-backer" href="/support-vuejs">
    成为赞助者
  </a>
</div>


-->
 
<div
    class="content process with-sidebar "
>
      
<div id="ad">
  <!-- start: special logic for cn -->
  <div
    class="wwads-cn wwads-vertical"
    data-id="53"
    style="max-width: 200px"
  ></div>
  <script
    type="text/javascript"
    src="https://cdn.wwads.cn/js/makemoney.js"
    async
  ></script>
  <!-- end: special logic for cn -->
  <!-- <script
    async
    type="text/javascript"
    src="//cdn.carbonads.com/carbon.js?serve=CEBDT27Y&placement=vuejsorg"
    id="_carbonads_js"
  ></script> -->
</div>

   
    <h1>网站上线部署流程</h1>
    

    <!-- start: special logic for cn -->
    <!-- start: special logic for cn -->
<!-- <div class="ad-pagetop">
  <a href="http://www.vueshop.com.cn/index.php?http_referer=vuejs" target="_blank" rel="noopener noreferrer">
    <span class="name">VUEshop</span>
    <span class="description">中国免费商城系统 - 搜豹商城系统 - 免费50小时 Vue 视频教程</span>
    <span class="action">立即查看 &gt;</span>
  </a>
</div> -->
<!-- end: special logic for cn -->

    <!-- end: special logic for cn -->

     <h2 id="一、网站运行机制"><a href="#一、网站运行机制" class="headerlink" title="一、网站运行机制"></a>一、网站运行机制</h2><h3 id="1、名词解释"><a href="#1、名词解释" class="headerlink" title="1、名词解释"></a>1、名词解释</h3><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.baidu.com">www.baidu.com</a></li>
<li><a target="_blank" rel="noopener" href="http://www.taobao.com">www.taobao.com</a></li>
<li><a target="_blank" rel="noopener" href="http://www.qq.com">www.qq.com</a></li>
</ul>
</blockquote>
<blockquote>
<p>域名俗称网址，是由一串用点分隔的名字组成，用于标识互联网上的计算机。<br>原本用于标识互联网上计算机使用的是 IP 地址，但是由于 IP 地址不便于记忆，所以人们便设计出来比较容易记忆的域名，然后通过 DNS 将域名和 IP 地址关联，这样人们便可以通过记忆域名直接访问到对应的计算机。</p>
</blockquote>
<h4 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h4><blockquote>
<p>DNS (Domain Name System)，可以理解为互联网上的一项服务，他可以将域名转换成其对应的 IP 地址。<br>可以将其理解为字典，字典中存储的就是域名和 IP 地址一一对应的键值对。<br>本地 hosts 文件<br>windows: c:\windows\system32\drivers\etc\hosts<br>mac: /etc/hosts</p>
</blockquote>
<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><blockquote>
<p>服务器其实就是一台计算机，但是这台计算机并和我们自己的的 PC 不一样，不是日常使用的，而是提供某项互联网服务的。<br>比如 web 服务器，能为我们提供网页服务，email 服务器，能为我们提供电子邮件服务，FTP 服务器能为我们提供文件存储服务等等。<br>为计算机安装不同的服务应用程序，即可提供相应的服务。<br>常见的 web 服务应用程序： Apache、Nginx、IIS、Node.js</p>
</blockquote>
<h3 id="2、-网站请求流程（简化版）"><a href="#2、-网站请求流程（简化版）" class="headerlink" title="2、 网站请求流程（简化版）"></a>2、 网站请求流程（简化版）</h3><h4 id="静态页面"><a href="#静态页面" class="headerlink" title="静态页面"></a>静态页面</h4><p>网页只请求和响应简单的 HTML、CSS、JavaScript 文件，未和服务端进行任何数据通信。这样的页面叫做静态页面。</p>
<h4 id="动态页面"><a href="#动态页面" class="headerlink" title="动态页面"></a>动态页面</h4><p>页面内有和服务器进行数据通信，这样的页面叫做动态页面。</p>
<h4 id="前后端分离的页面"><a href="#前后端分离的页面" class="headerlink" title="前后端分离的页面"></a>前后端分离的页面</h4><blockquote>
<p>前后端分离的项目中，页面中的数据渲染是在浏览器中完成的。</p>
</blockquote>
<p>前后端分离的页面请求分为两部分： 静态页面请求 + ajax 数据请求</p>
<p><img src="index.assets/1748243726987.png" alt="image"></p>
<p><img src="index.assets/1748243333844.png" alt="image"></p>
<h4 id="前后端不分离的页面"><a href="#前后端不分离的页面" class="headerlink" title="前后端不分离的页面"></a>前后端不分离的页面</h4><blockquote>
<p>前后端不分离的项目中，页面中的数据渲染操作是在服务器端完成的。</p>
</blockquote>
<p>前后端不分离的页面一次请求就能完成。</p>
<p><img src="index.assets/1748241289183.png" alt="image"></p>
<h2 id="二、网站上线部署流程"><a href="#二、网站上线部署流程" class="headerlink" title="二、网站上线部署流程"></a>二、网站上线部署流程</h2><h3 id="1、服务器购买"><a href="#1、服务器购买" class="headerlink" title="1、服务器购买"></a>1、服务器购买</h3><p>国内服务器： 阿里云 ECS(Elastic Compute Service)，腾讯云 CVM(Cloud Virtual Machine) 等<br>国外服务器： 日本 <a target="_blank" rel="noopener" href="https://www.vultr.com/">Vultr</a>, 美国 Linode, 谷歌云，微软 Azure，亚马逊 AWS 等<br>这一步需要创建好服务器实例，分配好外网 IP 地址。</p>
<h3 id="2、域名购买"><a href="#2、域名购买" class="headerlink" title="2、域名购买"></a>2、域名购买</h3><p>国内： 万网（阿里）、腾讯等<br>国外： Godaddy</p>
<h3 id="3、域名解析（配置-DNS）"><a href="#3、域名解析（配置-DNS）" class="headerlink" title="3、域名解析（配置 DNS）"></a>3、域名解析（配置 DNS）</h3><p>注册好域名之后需要将域名映射到自己服务器对应的 IP 地址，这样别人才能通过域名访问到我们的服务器。<br>这个步骤叫做域名解析，通过域名服务商提供的后台就可以操作，一般域名解析都会有延迟，不是即时生效的。</p>
<h3 id="4、服务器环境搭建"><a href="#4、服务器环境搭建" class="headerlink" title="4、服务器环境搭建"></a>4、服务器环境搭建</h3><p><strong>配置环境也可以参考<a href="/website/docker/">Docker</a>，部署更方便</strong></p>
<p>数据库环境：由于使用命令安装 Mongodb，MySql 数据库容易出现各种各样的问题，建议用 Docker 拉取镜像安装，用 docker compose 去管理</p>
<p>redis 服务：建议用 Docker 拉取镜像安装</p>
<p>Node 项目：打包成 Docker 镜像，在项目中创建 Dockerfile 文件，文件内容包括拉取镜像，下载依赖，运行项目，在 jenkins 中配置 shell 脚本文件，或者在服务器上找个目录配置 shell 文件，具体参考下面的自动化部署</p>
<p>nginx 和 node 可以直接在宿主机上进行下载</p>
<p>配置服务器，Mac 系统下直接用终端就 ok<br>windows 下需要用到 git bash, 或者别的工具（Putty）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">需要用到的 Linux 系统操作命令</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">远程连接命令</span><br>ssh root@域名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">展示当前文件夹路径</span><br>pwd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换文件夹目录</span><br>cd 目录路径<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">展示当前文件夹中内容</span><br>ls<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑文件</span><br>vim 文件路径<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">传输文件</span><br>scp 本地文件路径 root@域名:远程路径<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压文件命令</span><br>unzip<br></code></pre></td></tr></table></figure>
<h4 id="4-1-安装-CentOS-开发人员相关包"><a href="#4-1-安装-CentOS-开发人员相关包" class="headerlink" title="4.1 安装 CentOS 开发人员相关包"></a>4.1 安装 CentOS 开发人员相关包</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">yum groupinstall &#x27;Development tools&#x27;<br></code></pre></td></tr></table></figure>
<h4 id="4-2-配置免密登陆"><a href="#4-2-配置免密登陆" class="headerlink" title="4.2 配置免密登陆"></a>4.2 配置免密登陆</h4><p>在自己电脑上 生成本地 秘钥对，参考<a href="/tool/git/">git 如何生成密钥</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">生成的位置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">mac 在 ~/.ssh</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">windows 在 C:\<span class="hljs-built_in">users</span>\你的用户名\.ssh</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在服务器创建了一个.ssh 文件夹</span><br>mkdir .ssh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到这个文件夹</span><br>cd .ssh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建了一个文件</span><br>touch authorized_keys<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">我们把自己电脑上的 id_rsa.pub 文件中的内容 放到 authorized_keys文件中</span><br>echo &quot;公钥内容&quot; &gt;&gt; authorized_keys<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出服务器，下次直接就能免密登陆了</span><br>exit<br></code></pre></td></tr></table></figure>
<h4 id="4-3-安装-Nginx"><a href="#4-3-安装-Nginx" class="headerlink" title="4.3 安装 Nginx"></a>4.3 安装 Nginx</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加 Nginx 源</span><br>sudo yum install epel-release<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 Nginx</span><br>sudo yum install nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 Nginx</span><br>nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置防火墙规则</span><br>sudo firewall-cmd --permanent --zone=public --add-service=http<br>sudo firewall-cmd --permanent --zone=public --add-service=https<br>sudo firewall-cmd --reload<br></code></pre></td></tr></table></figure>
<h4 id="4-4-安装-Node-js"><a href="#4-4-安装-Node-js" class="headerlink" title="4.4 安装 Node.js"></a>4.4 安装 Node.js</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">yum自带源中没有Node.js,所以首先要获取Node.js资源：</span><br>curl --silent --location https://rpm.nodesource.com/setup_14.x | bash -<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 Node.js</span><br>yum install -y nodejs<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装完成之后使用如下指令测试安装是否成功</span><br>node -v<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装pm2 node.js程序管理工具</span><br>npm i pm2 -g<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用pm2 启动node.js项目</span><br>pm2 start 文件名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止</span><br>pm2 stop 文件名或者id<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从pm2的管理列表中删除</span><br>pm2 delete 文件名或者id<br></code></pre></td></tr></table></figure>
<h4 id="4-5-安装-MySQL"><a href="#4-5-安装-MySQL" class="headerlink" title="4.5 安装 MySQL"></a>4.5 安装 MySQL</h4><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载并安装 MySQL 源</span><br>wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm<br>sudo yum localinstall mysql80-community-release-el7-3.noarch.rpm<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 MySQL</span><br>sudo yum install mysql-community-server -y<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果上一步报认证密钥的错，那么将：/etc/yum.repos.d/mysql-community.repo中的gpgcheck改为0</span><br>gpgcheck=0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果上一步报错 执行下面的语句 之后 再次执行一下上面的安装Mysql的语句</span><br>sudo yum module disable mysql<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动MySQL</span><br>sudo systemctl start msyqld<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">找到默认密码</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">MySQL安装完毕之后会自动设置一个默认密码，我们需要找到默认密码</span><br>grep &#x27;temporary password&#x27; /var/log/mysqld.log<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">连接到MySQL数据库，修改密码</span><br>mysql -uroot -p<br>ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;要修改的密码&#x27;;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">远程连接到MySQL数据库，如果报错1130-host ... is not allowed to connect to this MySql server</span><br>解决方案是在服务器上先连接到数据库，然后按照以下命令操作<br>查看所有数据库：SHOW DATABASES;<br>切换到 mysql 数据库：USE mysql;<br>查看 mysql 数据库中的表：SHOW TABLES;<br>你应该能看到一个名为 user 的表，它存储了MySQL用户的登录权限信息<br>查看 user 表中的 Host 和 User 字段：SELECT Host, User FROM user;<br>修改 user 表中的 Host 值：UPDATE user SET Host = &#x27;%&#x27; WHERE User = &#x27;root&#x27;;<br>执行完后刷新权限，使更改立即生效：FLUSH PRIVILEGES;<br>重新使用可视化工具测试连接<br><br>参考文档：https://blog.csdn.net/qq_42943927/article/details/147632834<br></code></pre></td></tr></table></figure>
<h3 id="5、上传网站资源"><a href="#5、上传网站资源" class="headerlink" title="5、上传网站资源"></a>5、上传网站资源</h3><p>可以使用 <code>scp</code> 命令，也可以安装 FTP （vsftpd）工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">scp 本地文件 root@域名:远程路径<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在服务器创建文件夹</span><br>mkdir /home/nginx/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">把网页文件移动到创建好的文件夹里</span><br>mv ./dist.zip /home/nginx/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压压缩文件</span><br>cd /home/ningx<br>unzip ./dist.zip<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改文件夹名字</span><br>mv dist admin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">结果就是  /home/nginx/admin  这个文件夹中放的就是我们的网页文件了</span><br></code></pre></td></tr></table></figure>
<h3 id="6、配置-Nginx"><a href="#6、配置-Nginx" class="headerlink" title="6、配置 Nginx"></a>6、配置 Nginx</h3><p>创建一个 ilovefe.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd /etc/nginx/conf.d<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建配置文件</span><br>touch ilovefe.conf<br>vim ilovefe.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按i键 进出插入模式</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制下面的内容，粘贴进去</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">保存退出</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">按一下esc退出编辑模式</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后输入 下面的内容 敲回车</span><br><br>:wq<br></code></pre></td></tr></table></figure>
<p>ilovefe.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs configure">server &#123;<br>    listen       80;<br>    server_name  zzf.net.cn;<br>    location / &#123;<br>         `  root   /usr/local/src/dist;`<br>         `  index  index.html index.htm;`<br>         `  try_files $uri $uri/ /index.html;`<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>完整的配置文件示例，开启了 https</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs configure"># nginx.conf 或 server 配置中添加<br>map $http_user_agent $is_mobile &#123;<br>    default 0;<br>    ~*(iphone|ipod|android|blackberry|opera\ mini|windows\sce|palm|mobile) 1;<br>&#125;<br><br>server<br>&#123;<br>    listen 80;<br>    listen 443 ssl;<br>    listen 443 quic;<br>    http2 on;<br>    server_name zzf.net.cn www.zzf.net.cn;<br>    #<br><br>    # root /www/wwwroot/zzf.net.cn/;<br>    #CERT-APPLY-CHECK--START<br>    # 用于SSL证书申请时的文件验证相关配置 -- 请勿删除<br>    # include /www/server/panel/vhost/nginx/well-known/zzf.net.cn.conf;<br>    #CERT-APPLY-CHECK--END<br><br>    #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则<br>    #error_page 404/404.html;<br>    #HTTP_TO_HTTPS_START<br>    set $isRedcert 1;<br>    if ($server_port != 443) &#123;<br>        set $isRedcert 2;<br>    &#125;<br>    if ( $uri ~ /\.well-known/ ) &#123;<br>        set $isRedcert 1;<br>    &#125;<br>    if ($isRedcert != 1) &#123;<br>        rewrite ^(/.*)$ https://$host$1 permanent;<br>    &#125;<br>    #HTTP_TO_HTTPS_END<br><br>    ssl_certificate     /root/.acme.sh/zzf.net.cn_ecc/fullchain.cer;<br>    ssl_certificate_key /root/.acme.sh/zzf.net.cn_ecc/zzf.net.cn.key;<br>    # ssl_certificate    /www/server/panel/vhost/cert/zzf.net.cn/fullchain.pem;<br>    # ssl_certificate_key    /www/server/panel/vhost/cert/zzf.net.cn/privkey.pem;<br>    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;<br>    ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;<br>    ssl_prefer_server_ciphers on;<br>    ssl_session_tickets on;<br>    ssl_session_cache shared:SSL:10m;<br>    ssl_session_timeout 10m;<br>    add_header Strict-Transport-Security &quot;max-age=31536000&quot;;<br>    add_header Alt-Svc &#x27;quic=&quot;:443&quot;; h3=&quot;:443&quot;; h3-29=&quot;:443&quot;; h3-27=&quot;:443&quot;;h3-25=&quot;:443&quot;; h3-T050=&quot;:443&quot;; h3-Q050=&quot;:443&quot;;h3-Q049=&quot;:443&quot;;h3-Q048=&quot;:443&quot;; h3-Q046=&quot;:443&quot;; h3-Q043=&quot;:443&quot;&#x27;;<br>    error_page 497  https://$host$request_uri;<br><br>    #SSL-END<br><br>    #ERROR-PAGE-START  错误页配置，可以注释、删除或修改<br>    error_page 404 /404.html;<br>    #error_page 502 /502.html;<br>    #ERROR-PAGE-END<br><br>    #PHP-INFO-START  PHP引用配置，可以注释或修改<br>    # include enable-php-00.conf;<br>    #PHP-INFO-END<br><br>    #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效<br>    # include /www/server/panel/vhost/rewrite/zzf.net.cn.conf;<br>    #REWRITE-END<br><br><br>    # 默认根目录指向前台 dist<br>    root /www/wwwroot/zzf.net.cn/dist;<br>    index index.html index.htm;<br><br>   location / &#123;<br>     try_files $uri $uri/ /index.html;<br>     if ($is_mobile = 1) &#123;<br>          return 301 https://m.zzf.net.cn$request_uri;<br>      &#125;<br>    &#125;<br><br>     location /webhook &#123;<br>        proxy_pass http://127.0.0.1:4000;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>    &#125;<br><br>    location /webhook-admin &#123;<br>        proxy_pass http://127.0.0.1:4001;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>    &#125;<br><br>    location /webhook-server &#123;<br>        proxy_pass http://127.0.0.1:4002;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>    &#125;<br><br>    location /webhook-h5 &#123;<br>        proxy_pass http://127.0.0.1:4003;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>    &#125;<br><br>    location /webhook-compc &#123;<br>        proxy_pass http://127.0.0.1:4005;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>    &#125;<br><br>    location /webhook-comkoa &#123;<br>        proxy_pass http://127.0.0.1:4006;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>    &#125;<br><br>    # 代理后端接口服务<br>    location ^~ /api/ &#123;<br>        rewrite ^/api/(.*)$ /api/$1 break;<br>        proxy_pass http://127.0.0.1:3001;<br>    &#125;<br><br>    # 代理websocket服务<br>    location ^~ /websocket &#123;<br>        proxy_pass http://127.0.0.1:11007/;  # 内部转发到11007端口<br>        proxy_http_version 1.1;<br>        proxy_set_header Upgrade $http_upgrade;<br>        proxy_set_header Connection &quot;upgrade&quot;;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>        proxy_set_header X-Forwarded-Proto $scheme;<br><br>        # 超时设置<br>        proxy_read_timeout 3600s;<br>        proxy_send_timeout 3600s;<br>    &#125;<br><br><br>    #禁止访问的文件或目录<br>    location ~ ^/(\.user.ini|\.htaccess|\.git|\.env|\.svn|\.project|LICENSE|README.md)<br>    &#123;<br>        return 404;<br>    &#125;<br><br>    #一键申请SSL证书验证目录相关设置<br>    location ~ \.well-known&#123;<br>        allow all;<br>    &#125;<br><br>    #禁止在证书验证目录放入敏感文件<br>    if ( $uri ~ &quot;^/\.well-known/.*\.(php|jsp|py|js|css|lua|ts|go|zip|tar\.gz|rar|7z|sql|bak)$&quot; ) &#123;<br>        return 403;<br>    &#125;<br><br>    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$<br>    &#123;<br>        expires      30d;<br>        error_log /dev/null;<br>        access_log /dev/null;<br>    &#125;<br><br>    location ~ .*\.(js|css)?$<br>    &#123;<br>        expires      12h;<br>        error_log /dev/null;<br>        access_log /dev/null;<br>    &#125;<br>    access_log  /www/wwwlogs/zzf.net.cn.log;<br>    error_log  /www/wwwlogs/zzf.net.cn.error.log;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="7、接口项目部署步骤"><a href="#7、接口项目部署步骤" class="headerlink" title="7、接口项目部署步骤"></a>7、接口项目部署步骤</h3><ol>
<li>修改配置文件中的 mysql 数据库密码</li>
<li>上传项目压缩文件到服务器</li>
<li>在服务器上解压项目文件到 /home/nginx/ilovefeadmin</li>
<li>为项目安装依赖项 npm i</li>
<li>修改 mysql 数据库 密码规则</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">use mysql;<br>ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;新密码&#x27; PASSWORD EXPIRE NEVER;<br>ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;<br><br># 查看是否已经修改成功<br>select user,host,plugin from user where user=&#x27;root&#x27;;<br><br></code></pre></td></tr></table></figure>
<ol start="6">
<li>创建新的数据库</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">create database mysite;<br></code></pre></td></tr></table></figure>
<ol start="7">
<li>nginx 配置文件中添加反向代理的配置：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>location ^\~ /api/ &#123;<br>    `  rewrite ^/api/(.\*)$ /api/$1 break;`<br>    `  proxy\_pass http://127.0.0.1:3001;`<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="8">
<li>nginx 配置后台管理系统的目录：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">location /admin &#123;<br>    `  alias /usr/local/src/admin;`<br>    `  index index.html index.htm;`<br>    `  try\_files $uri $uri/ /index.html;`<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="9">
<li>nginx 配置静态文件服务器：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>location /static/ &#123;<br>    `  alias /usr/local/src/server/public/static/;`<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="三、自动化部署"><a href="#三、自动化部署" class="headerlink" title="三、自动化部署"></a>三、自动化部署</h2><p><strong>自动化部署常用的插件是 jenkins，参考<a href="/website/docker/">Docker 安装 jenkins</a>，如果你不想借助 jenkins，可以参考以下解决方案</strong></p>
<p>通过配置 Webhook + Shell 脚本 来实现「Git 有最新提交时，仅拉取指定文件」的部署需求<br>当远程 Git 仓库有新提交时，只拉取特定文件（如 /dist/** 或 /public/index.html）而不是整个项目</p>
<h3 id="1、准备条件"><a href="#1、准备条件" class="headerlink" title="1、准备条件"></a>1、准备条件</h3><ul>
<li>你已有 Git 仓库（GitHub、Gitee 等）</li>
<li>宝塔服务器已安装 Git、Node.js、PM2（可选）</li>
<li>项目已初始化为 Git 仓库（git clone 方式）</li>
</ul>
<h3 id="2、创建自动拉取脚本（只同步指定文件）"><a href="#2、创建自动拉取脚本（只同步指定文件）" class="headerlink" title="2、创建自动拉取脚本（只同步指定文件）"></a>2、创建自动拉取脚本（只同步指定文件）</h3><h4 id="前端项目的做法"><a href="#前端项目的做法" class="headerlink" title="前端项目的做法"></a>前端项目的做法</h4><p>假设前端项目部署在 /www/wwwroot/zzf.net.cn，你只想更新仓库中的 dist/ 到这个目录<br>（1）在服务器上创建一个暂存文件，拉取完整仓库到缓存目录，如果想使用 ssh 方式拉取代码，可以参考<a href="/tool/git/">git</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /www/git-temp<br><span class="hljs-built_in">cd</span> /www/git-temp<br>git <span class="hljs-built_in">clone</span> https://github.com/zhenfeng95/mysite.git<br></code></pre></td></tr></table></figure>
<p>（2）创建部署脚本 /www/deploy/deploy.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 1. 进入临时目录</span><br><span class="hljs-built_in">cd</span> /www/git-temp/mysite || <span class="hljs-built_in">exit</span><br><br><span class="hljs-comment"># 2. 拉取最新代码</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Pulling latest code from GitHub...&quot;</span><br>git reset --hard HEAD<br>git clean -<span class="hljs-built_in">df</span><br>git pull origin main<br><br><span class="hljs-comment"># 3. 拷贝指定文件（只同步 dist 目录）</span><br><span class="hljs-built_in">cp</span> -r dist/* /www/wwwroot/zzf.net.cn/dist/<br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Deploy finished at <span class="hljs-subst">$(date)</span>&quot;</span><br></code></pre></td></tr></table></figure>
<p>带邮件通知的做法，用的是centos系统自带curl发送邮件的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deploy_with_email.sh</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">========== 配置 ==========</span><br>CONFIG_QQ_EMAIL=&quot;您的QQ邮箱@qq.com&quot;<br>CONFIG_QQ_AUTH_CODE=&quot;您的授权码&quot;<br>CONFIG_TO_EMAIL=&quot;您的接收邮箱@example.com&quot;<br>PROJECT_NAME=&quot;您的项目名字&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">==========================</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">邮件发送函数</span><br>send_deploy_email() &#123;<br>    local status=$1  # 0=成功, 1=失败<br>    local message=&quot;$2&quot;<br>    <br>    if [ $status -eq 0 ]; then<br>        subject=&quot;✅ $&#123;PROJECT_NAME&#125;部署成功 - $(date &#x27;+%m-%d %H:%M&#x27;)&quot;<br>    else<br>        subject=&quot;❌ $&#123;PROJECT_NAME&#125;部署失败 - $(date &#x27;+%m-%d %H:%M&#x27;)&quot;<br>    fi<br>    <br>    # 创建邮件内容<br>    cat &gt; /tmp/deploy_email.txt &lt;&lt; EOF<br>From: $&#123;CONFIG_QQ_EMAIL&#125;<br>To: $&#123;CONFIG_TO_EMAIL&#125;<br>Subject: $&#123;subject&#125;<br>Date: $(date -R)<br><br>项目: $&#123;PROJECT_NAME&#125;<br>时间: $(date)<br>服务器: $(hostname)<br>状态: $&#123;subject%% *&#125;<br><br>详情:<br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;message&#125;</span><br><br>文件统计:<br><span class="hljs-meta prompt_">$</span><span class="language-bash">(find /www/wwwroot/mgt.zzf.net.cn/dist/ -<span class="hljs-built_in">type</span> f 2&gt;/dev/null | <span class="hljs-built_in">wc</span> -l) 个文件</span><br><br>--- 自动发送 ---<br>EOF<br>    <br>    # 发送邮件<br>    curl --ssl-reqd --silent \<br>      --url &#x27;smtps://smtp.qq.com:465&#x27; \<br>      --user &quot;$&#123;CONFIG_QQ_EMAIL&#125;:$&#123;CONFIG_QQ_AUTH_CODE&#125;&quot; \<br>      --mail-from &quot;$&#123;CONFIG_QQ_EMAIL&#125;&quot; \<br>      --mail-rcpt &quot;$&#123;CONFIG_TO_EMAIL&#125;&quot; \<br>      --upload-file /tmp/deploy_email.txt<br>    <br>    rm -f /tmp/deploy_email.txt<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">主部署流程</span><br>main() &#123;<br>    echo &quot;开始部署...&quot;<br>    <br>    # 原有部署步骤<br>    cd /www/git-temp/community-admin || &#123;<br>        send_deploy_email 1 &quot;无法进入目录 /www/git-temp/community-admin&quot;<br>        exit 1<br>    &#125;<br>    <br>    git reset --hard HEAD<br>    git clean -df<br>    <br>    if ! git pull origin main; then<br>        send_deploy_email 1 &quot;Git拉取失败&quot;<br>        exit 1<br>    fi<br>    <br>    if cp -r dist/* /www/wwwroot/mgt.zzf.net.cn/dist/; then<br>        file_count=$(find /www/wwwroot/mgt.zzf.net.cn/dist/ -type f | wc -l)<br>        send_deploy_email 0 &quot;成功同步 $&#123;file_count&#125; 个文件&quot;<br>        echo &quot;✅ 部署完成&quot;<br>    else<br>        send_deploy_email 1 &quot;文件拷贝失败&quot;<br>        exit 1<br>    fi<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行</span><br>main<br></code></pre></td></tr></table></figure>
<p>保存后赋权：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x /www/deploy/deploy.sh<br></code></pre></td></tr></table></figure>
<p>如果你希望只拉取特定文件（例如只拉 config/ 目录或 index.html），可以在 deploy.sh 中用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git checkout origin/main -- config/<br>git checkout origin/main -- index.html<br></code></pre></td></tr></table></figure>
<h4 id="后端项目的做法"><a href="#后端项目的做法" class="headerlink" title="后端项目的做法"></a>后端项目的做法</h4><p>（1）后端项目部署在/www/wwwroot/community-koa，直接在/www/wwwroot/目录下拉取代码，后端项目运行需要整个仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/zhenfeng95/community-koa.git<br></code></pre></td></tr></table></figure>
<p><strong>Docker 镜像做法</strong></p>
<p>（2）创建部署脚本 /www/deploy/deploy-comkoa.sh，该脚本文件会读取项目根目录下的 Dockerfile 文件，并生成一个 web_api 的镜像，运行镜像即可访问后端服务，通过 docker ps | grep web_api 查看是否运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 进入项目目录</span><br>cd /www/wwwroot/community-koa || exit<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 拉取最新代码</span><br>echo &quot;Pulling latest code from GitHub...&quot;<br>git pull origin main<br><br>CONTAINER=&quot;web_api&quot;<br>PORT=11005<br>PORT_WEBSOCKET=11007 # 启动websocket服务<br>image_name=&quot;web_api&quot;<br>tag=&quot;1.0&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">完成镜像的构建</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker built -t web_pc:1.0 .</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">后面的.代表使用工程目录下面的Docker file文件</span><br>docker build --no-cache -t $&#123;image_name&#125;:$&#123;tag&#125; .<br><br>RUNNING=$&#123;docker inspect --format=&quot;&#123;&#123; .State.Running&#125;&#125;&quot; $CONTAINER 2 &gt; /dev/null&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">条件判断</span><br>if [ ! -n $RUNNING ]; then<br>	echo &quot;$CONTAINER does not exit&quot;<br>    return 1<br>fi<br><br>if [ $RUNNING == &quot;false&quot; ]; then<br>	echo &quot;$CONTAINER is not running&quot;<br>    return 2<br>else<br>	echo &quot;$CONTAINER is running&quot;<br>    # 删除相同名字的容器<br>    matchingStarted=$(docker ps --filter=&quot;name=$CONTAINER&quot; -q | xargs)<br>    if [ -n $matchingStarted ]; then<br>    	docker stop $matchingStarted<br>    fi<br><br>    matching=$(docker ps -a --filter=&quot;name=$CONTAINER&quot; -q | xargs)<br>    if [ -n $matching ]; then<br>    	docker rm $matching<br>    fi<br>fi<br><br>echo &quot;RUNNING is $&#123;RUNNING&#125;&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行镜像</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker run -itd --name <span class="hljs-variable">$CONTAINER</span> -p <span class="hljs-variable">$PORT</span>:3002 <span class="hljs-variable">$&#123;image_name&#125;</span>:<span class="hljs-variable">$&#123;tag&#125;</span></span><br><br>docker run -d --name $CONTAINER -p $PORT:3002 -p $PORT_WEBSOCKET:3003 $&#123;image_name&#125;:$&#123;tag&#125;<br><br>echo &quot;Deploy finished at $(date)&quot;<br><br>exit 0<br></code></pre></td></tr></table></figure>
<p>带邮件通知的做法：</p>
<p>（1）包含热更新流程（服务中断&lt;30秒），使后端服务没有长时间的暂停（推荐）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">代码拉取 → 构建镜像 → 启动新容器 → 等待就绪 → 快速切换 → 清理旧容器<br>                                 ↑<br>                         仅此阶段服务中断<br></code></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">============================================</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">热更新部署脚本 - 修复健康检查问题版</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">============================================</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--------------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置区域，参数需要改动</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--------------------------------</span><br>PROJECT_NAME=&quot;community-koa&quot;<br>PROJECT_PATH=&quot;/www/wwwroot/$&#123;PROJECT_NAME&#125;&quot;<br>GIT_BRANCH=&quot;main&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">容器配置</span><br>CONTAINER_NAME=&quot;web_api&quot;<br>CONTAINER_NEW_NAME=&quot;web_api_new&quot;<br>IMAGE_NAME=&quot;web_api&quot;<br>IMAGE_TAG=&quot;1.0&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">端口配置</span><br>STANDARD_WEB_PORT=11005      # 最终Web端口<br>STANDARD_WS_PORT=11007       # 最终WebSocket端口<br>TEMP_WEB_PORT=11015          # 临时Web端口（标准+10）<br>TEMP_WS_PORT=11017           # 临时WebSocket端口（标准+10）<br>CONTAINER_PORT_WEB=3002<br>CONTAINER_PORT_WS=3003<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">邮件配置，参数需要改动</span><br>QQ_EMAIL=&quot;您的QQ邮箱@qq.com&quot;<br>QQ_AUTH_CODE=&quot;您的QQ邮箱授权码&quot;<br>NOTIFY_EMAIL=&quot;接收通知的邮箱@example.com&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">部署参数</span><br>MAX_STARTUP_WAIT=45          # 增加到45秒（Koa应用启动可能需要更长时间）<br>HEALTH_CHECK_INTERVAL=3      # 检查间隔增加到3秒<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">健康检查配置</span><br>HEALTH_CHECK_PATH=&quot;/&quot;        # 健康检查路径，根据您的应用调整<br>HEALTH_CHECK_TIMEOUT=5       # curl超时时间<br>READINESS_KEYWORDS=&quot;listening|started|ready|Server running|MongoDB.*connection opened&quot;  # 应用就绪关键词<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">日志配置</span><br>LOG_FILE=&quot;/var/log/deploy_$&#123;PROJECT_NAME&#125;.log&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">--------------------------------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">全局变量</span><br>DEPLOY_START_TIME=&quot;&quot;<br>DEPLOY_DETAILS=&quot;&quot;<br>CURRENT_STAGE=&quot;&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化</span><br>init_deployment() &#123;<br>    DEPLOY_START_TIME=$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)<br>    echo &quot;========== 热更新部署开始: $&#123;DEPLOY_START_TIME&#125; ==========&quot; | tee -a &quot;$LOG_FILE&quot;<br>    log &quot;INFO&quot; &quot;使用临时端口避免冲突: $&#123;TEMP_WEB_PORT&#125;/$&#123;TEMP_WS_PORT&#125;&quot;<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置当前阶段（修复缺失的函数）</span><br>set_stage() &#123;<br>    CURRENT_STAGE=&quot;$1&quot;<br>    log &quot;INFO&quot; &quot;=== $&#123;CURRENT_STAGE&#125; ===&quot;<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">日志函数</span><br>log() &#123;<br>    local level=&quot;$1&quot;<br>    local message=&quot;$2&quot;<br>    local timestamp=$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)<br>    echo &quot;[$&#123;timestamp&#125;] [$&#123;level&#125;] $&#123;message&#125;&quot; | tee -a &quot;$LOG_FILE&quot;<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">发送邮件函数（简版，确保可用）</span><br>send_deploy_email() &#123;<br>    local status=&quot;$1&quot;<br>    local subject=&quot;$2&quot;<br>    local message=&quot;$3&quot;<br>    <br>    local email_subject=&quot;$&#123;status&#125; $&#123;PROJECT_NAME&#125;部署$&#123;subject&#125; - $(date &#x27;+%m-%d %H:%M&#x27;)&quot;<br>    local mail_file=&quot;/tmp/deploy_email_$(date +%s).txt&quot;<br>    <br>    cat &gt; &quot;$mail_file&quot; &lt;&lt; EOF<br>From: $&#123;QQ_EMAIL&#125;<br>To: $&#123;NOTIFY_EMAIL&#125;<br>Subject: $&#123;email_subject&#125;<br>Date: $(date -R)<br><br>项目: $&#123;PROJECT_NAME&#125;<br>状态: $&#123;status&#125;<br>时间: $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)<br>服务器: $(hostname)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;message&#125;</span><br><br>最近日志:<br><span class="hljs-meta prompt_">$</span><span class="language-bash">(<span class="hljs-built_in">tail</span> -20 <span class="hljs-string">&quot;<span class="hljs-variable">$LOG_FILE</span>&quot;</span> 2&gt;/dev/null || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;无日志&quot;</span>)</span><br>EOF<br>    <br>    curl --ssl-reqd --silent \<br>        --url &#x27;smtps://smtp.qq.com:465&#x27; \<br>        --user &quot;$&#123;QQ_EMAIL&#125;:$&#123;QQ_AUTH_CODE&#125;&quot; \<br>        --mail-from &quot;$&#123;QQ_EMAIL&#125;&quot; \<br>        --mail-rcpt &quot;$&#123;NOTIFY_EMAIL&#125;&quot; \<br>        --upload-file &quot;$mail_file&quot;<br>    <br>    local result=$?<br>    rm -f &quot;$mail_file&quot;<br>    <br>    if [ $result -eq 0 ]; then<br>        log &quot;INFO&quot; &quot;邮件发送成功&quot;<br>    else<br>        log &quot;ERROR&quot; &quot;邮件发送失败&quot;<br>    fi<br>    <br>    return $result<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查端口占用</span><br>check_port_availability() &#123;<br>    local port=$1<br>    local type=$2<br>    <br>    if ss -tulpn | grep -q &quot;:$&#123;port&#125;\s&quot;; then<br>        log &quot;WARN&quot; &quot;端口 $&#123;port&#125; ($&#123;type&#125;) 已被占用&quot;<br>        return 1<br>    else<br>        log &quot;INFO&quot; &quot;端口 $&#123;port&#125; ($&#123;type&#125;) 可用&quot;<br>        return 0<br>    fi<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查应用健康状态（多维度检查）</span><br>check_container_health() &#123;<br>    local container_name=&quot;$1&quot;<br>    local port=&quot;$2&quot;<br>    <br>    # 1. 检查容器进程状态<br>    if [ &quot;$(docker inspect -f &#x27;&#123;&#123;.State.Running&#125;&#125;&#x27; &quot;$container_name&quot; 2&gt;/dev/null)&quot; != &quot;true&quot; ]; then<br>        log &quot;DEBUG&quot; &quot;容器进程未运行&quot;<br>        return 1<br>    fi<br>    <br>    # 2. 检查应用日志中的就绪关键词<br>    local container_logs=$(docker logs --tail=10 &quot;$container_name&quot; 2&gt;&amp;1)<br>    if echo &quot;$container_logs&quot; | grep -q -E -i &quot;$READINESS_KEYWORDS&quot;; then<br>        log &quot;DEBUG&quot; &quot;日志检查通过，找到就绪关键词&quot;<br>        return 0<br>    fi<br>    <br>    # 3. HTTP健康检查（可选，如果应用有HTTP接口）<br>    if command -v curl &amp;&gt; /dev/null; then<br>        if curl -s -f --max-time &quot;$HEALTH_CHECK_TIMEOUT&quot; \<br>           &quot;http://localhost:$&#123;port&#125;$&#123;HEALTH_CHECK_PATH&#125;&quot; &gt; /dev/null 2&gt;&amp;1; then<br>            log &quot;DEBUG&quot; &quot;HTTP健康检查通过 (端口:$&#123;port&#125;)&quot;<br>            return 0<br>        fi<br>    fi<br>    <br>    # 4. 检查特定进程是否在运行（例如node进程）<br>    if docker exec &quot;$container_name&quot; ps aux 2&gt;/dev/null | grep -q -E &quot;node|npm&quot;; then<br>        log &quot;DEBUG&quot; &quot;应用进程在运行&quot;<br>        return 0<br>    fi<br>    <br>    return 1<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动新容器（使用临时端口）</span><br>start_new_container_temp_port() &#123;<br>    set_stage &quot;阶段2：启动新容器(临时端口)&quot;<br>    <br>    log &quot;INFO&quot; &quot;检查临时端口可用性...&quot;<br>    check_port_availability &quot;$TEMP_WEB_PORT&quot; &quot;临时Web&quot;<br>    check_port_availability &quot;$TEMP_WS_PORT&quot; &quot;临时WebSocket&quot;<br>    <br>    log &quot;INFO&quot; &quot;使用临时端口启动新容器...&quot;<br>    log &quot;INFO&quot; &quot;临时端口: $&#123;TEMP_WEB_PORT&#125;-&gt;$&#123;CONTAINER_PORT_WEB&#125;, $&#123;TEMP_WS_PORT&#125;-&gt;$&#123;CONTAINER_PORT_WS&#125;&quot;<br>    <br>    # 启动新容器（临时端口）<br>    local container_id<br>    if ! container_id=$(docker run -d \<br>        --name &quot;$CONTAINER_NEW_NAME&quot; \<br>        -p &quot;$&#123;TEMP_WEB_PORT&#125;:$&#123;CONTAINER_PORT_WEB&#125;&quot; \<br>        -p &quot;$&#123;TEMP_WS_PORT&#125;:$&#123;CONTAINER_PORT_WS&#125;&quot; \<br>        &quot;$&#123;IMAGE_NAME&#125;:$&#123;IMAGE_TAG&#125;&quot; 2&gt;&amp;1); then<br>        log &quot;ERROR&quot; &quot;新容器启动失败: $&#123;container_id&#125;&quot;<br>        return 1<br>    fi<br>    <br>    # 提取容器ID<br>    container_id=$(echo &quot;$container_id&quot; | tr -d &#x27;\n&#x27;)<br>    if [ $&#123;#container_id&#125; -eq 64 ]; then<br>        log &quot;INFO&quot; &quot;新容器启动成功，ID: $&#123;container_id:0:12&#125;&quot;<br>        log &quot;INFO&quot; &quot;临时访问地址: http://$(hostname -I | awk &#x27;&#123;print $1&#125;&#x27;):$&#123;TEMP_WEB_PORT&#125;&quot;<br>        <br>        # 立即查看启动日志<br>        sleep 2<br>        local startup_logs=$(docker logs --tail=5 &quot;$CONTAINER_NEW_NAME&quot; 2&gt;&amp;1)<br>        log &quot;DEBUG&quot; &quot;容器启动日志: $&#123;startup_logs&#125;&quot;<br>        <br>        DEPLOY_DETAILS=&quot;$&#123;DEPLOY_DETAILS&#125;新容器ID: $&#123;container_id:0:12&#125;\n临时端口: $&#123;TEMP_WEB_PORT&#125;,$&#123;TEMP_WS_PORT&#125;\n&quot;<br>        return 0<br>    else<br>        log &quot;ERROR&quot; &quot;获取容器ID失败: $&#123;container_id&#125;&quot;<br>        return 1<br>    fi<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">等待新容器就绪（改进的健康检查）</span><br>wait_for_new_container_temp() &#123;<br>    set_stage &quot;阶段3：检查新容器健康&quot;<br>    <br>    log &quot;INFO&quot; &quot;等待新容器就绪，最多$&#123;MAX_STARTUP_WAIT&#125;秒...&quot;<br>    log &quot;INFO&quot; &quot;就绪关键词: $&#123;READINESS_KEYWORDS&#125;&quot;<br>    <br>    local wait_time=0<br>    local last_log_check=0<br>    local consecutive_healthy_checks=0<br>    local required_healthy_checks=2  # 需要连续2次检查通过<br>    <br>    while [ $wait_time -lt $MAX_STARTUP_WAIT ]; do<br>        # 定期输出日志（每10秒）<br>        if [ $((wait_time % 10)) -eq 0 ]; then<br>            log &quot;INFO&quot; &quot;等待容器启动... $&#123;wait_time&#125;/$&#123;MAX_STARTUP_WAIT&#125;秒&quot;<br>            <br>            # 每10秒输出一次最新日志<br>            if [ $last_log_check -eq 0 ] || [ $((wait_time - last_log_check)) -ge 10 ]; then<br>                local recent_logs=$(docker logs --tail=5 &quot;$CONTAINER_NEW_NAME&quot; 2&gt;&amp;1 | sed &#x27;:a;N;$!ba;s/\n/; /g&#x27;)<br>                if [ -n &quot;$recent_logs&quot; ]; then<br>                    log &quot;DEBUG&quot; &quot;最近日志: $&#123;recent_logs&#125;&quot;<br>                fi<br>                last_log_check=$wait_time<br>            fi<br>        fi<br>        <br>        # 检查容器健康状态<br>        if check_container_health &quot;$CONTAINER_NEW_NAME&quot; &quot;$TEMP_WEB_PORT&quot;; then<br>            consecutive_healthy_checks=$((consecutive_healthy_checks + 1))<br>            log &quot;DEBUG&quot; &quot;健康检查通过 ($&#123;consecutive_healthy_checks&#125;/$&#123;required_healthy_checks&#125;)&quot;<br>            <br>            if [ $consecutive_healthy_checks -ge $required_healthy_checks ]; then<br>                # 最终确认：输出完整就绪日志<br>                local ready_logs=$(docker logs &quot;$CONTAINER_NEW_NAME&quot; 2&gt;&amp;1 | grep -E -i &quot;$READINESS_KEYWORDS&quot; | tail -3)<br>                log &quot;INFO&quot; &quot;✅ 新容器就绪！等待时间: $&#123;wait_time&#125;秒&quot;<br>                log &quot;INFO&quot; &quot;就绪日志: $&#123;ready_logs&#125;&quot;<br>                <br>                DEPLOY_DETAILS=&quot;$&#123;DEPLOY_DETAILS&#125;容器就绪时间: $&#123;wait_time&#125;秒\n&quot;<br>                return 0<br>            fi<br>        else<br>            consecutive_healthy_checks=0<br>        fi<br>        <br>        sleep &quot;$HEALTH_CHECK_INTERVAL&quot;<br>        wait_time=$((wait_time + HEALTH_CHECK_INTERVAL))<br>    done<br>    <br>    # 超时处理：输出详细日志<br>    log &quot;ERROR&quot; &quot;新容器在$&#123;MAX_STARTUP_WAIT&#125;秒内未就绪&quot;<br>    log &quot;ERROR&quot; &quot;=== 容器最后20行日志 ===&quot;<br>    docker logs --tail=20 &quot;$CONTAINER_NEW_NAME&quot; 2&gt;&amp;1 | tee -a &quot;$LOG_FILE&quot;<br>    log &quot;ERROR&quot; &quot;=== 容器状态 ===&quot;<br>    docker inspect --format=&#x27;&#123;&#123;json .State&#125;&#125;&#x27; &quot;$CONTAINER_NEW_NAME&quot; 2&gt;&amp;1 | tee -a &quot;$LOG_FILE&quot;<br>    <br>    return 1<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行热切换</span><br>perform_hot_swap_with_ports() &#123;<br>    set_stage &quot;阶段4：执行热切换&quot;<br>    <br>    local swap_start=$(date +%s)<br>    log &quot;INFO&quot; &quot;开始热切换（服务中断开始）...&quot;<br>    <br>    # 1. 停止旧容器（释放标准端口）<br>    if docker inspect &quot;$CONTAINER_NAME&quot; &gt; /dev/null 2&gt;&amp;1; then<br>        log &quot;INFO&quot; &quot;停止旧容器: $&#123;CONTAINER_NAME&#125;&quot;<br>        if docker stop &quot;$CONTAINER_NAME&quot;; then<br>            log &quot;INFO&quot; &quot;旧容器已停止&quot;<br>            sleep 2  # 等待端口释放<br>        else<br>            log &quot;WARN&quot; &quot;停止旧容器失败，可能已不存在&quot;<br>        fi<br>    fi<br>    <br>    # 2. 停止新容器（临时端口）<br>    log &quot;INFO&quot; &quot;停止新容器准备端口切换...&quot;<br>    docker stop &quot;$CONTAINER_NEW_NAME&quot;<br>    <br>    # 3. 移除旧容器<br>    docker rm &quot;$CONTAINER_NAME&quot; 2&gt;/dev/null &amp;&amp; log &quot;INFO&quot; &quot;旧容器已移除&quot;<br>    <br>    # 4. 重命名新容器<br>    docker rename &quot;$CONTAINER_NEW_NAME&quot; &quot;$CONTAINER_NAME&quot;<br>    <br>    # 5. 修改容器端口绑定（需要重新创建容器）<br>    log &quot;INFO&quot; &quot;重新创建容器使用标准端口: $&#123;STANDARD_WEB_PORT&#125;/$&#123;STANDARD_WS_PORT&#125;&quot;<br>    <br>    # 先获取容器的其他配置（环境变量、卷等）<br>    local env_vars=$(docker inspect --format=&#x27;&#123;&#123;range .Config.Env&#125;&#125;&#123;&#123;println .&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; &quot;$CONTAINER_NAME&quot; 2&gt;/dev/null | grep -v &quot;^$&quot; | sed &#x27;s/^/-e &quot;/;s/$/&quot;/&#x27; | tr &#x27;\n&#x27; &#x27; &#x27;)<br>    <br>    # 移除旧容器实例<br>    docker rm &quot;$CONTAINER_NAME&quot; 2&gt;/dev/null<br>    <br>    # 使用标准端口重新创建<br>    if ! docker run -d \<br>        --name &quot;$CONTAINER_NAME&quot; \<br>        -p &quot;$&#123;STANDARD_WEB_PORT&#125;:$&#123;CONTAINER_PORT_WEB&#125;&quot; \<br>        -p &quot;$&#123;STANDARD_WS_PORT&#125;:$&#123;CONTAINER_PORT_WS&#125;&quot; \<br>        $&#123;env_vars&#125; \<br>        &quot;$&#123;IMAGE_NAME&#125;:$&#123;IMAGE_TAG&#125;&quot;; then<br>        log &quot;ERROR&quot; &quot;重新创建容器失败&quot;<br>        return 1<br>    fi<br>    <br>    # 6. 验证最终容器<br>    sleep 3<br>    if check_container_health &quot;$CONTAINER_NAME&quot; &quot;$STANDARD_WEB_PORT&quot;; then<br>        log &quot;INFO&quot; &quot;✅ 最终容器运行正常&quot;<br>    else<br>        log &quot;ERROR&quot; &quot;最终容器健康检查失败&quot;<br>        docker logs --tail=10 &quot;$CONTAINER_NAME&quot; 2&gt;&amp;1 | tee -a &quot;$LOG_FILE&quot;<br>        return 1<br>    fi<br>    <br>    local swap_end=$(date +%s)<br>    local swap_duration=$((swap_end - swap_start))<br>    <br>    log &quot;INFO&quot; &quot;热切换完成，耗时: $&#123;swap_duration&#125;秒&quot;<br>    DEPLOY_DETAILS=&quot;$&#123;DEPLOY_DETAILS&#125;热切换耗时: $&#123;swap_duration&#125;秒\n&quot;<br>    <br>    return 0<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">主部署流程</span><br>main_deployment() &#123;<br>    init_deployment<br>    <br>    set_stage &quot;阶段1：准备工作&quot;<br>    cd &quot;$PROJECT_PATH&quot; || &#123;<br>        log &quot;ERROR&quot; &quot;项目目录不存在: $&#123;PROJECT_PATH&#125;&quot;<br>        send_deploy_email &quot;failure&quot; &quot;目录错误&quot; &quot;项目目录不存在&quot;<br>        return 1<br>    &#125;<br>    <br>    # 拉取代码<br>    log &quot;INFO&quot; &quot;拉取最新代码...&quot;<br>    if ! git pull origin &quot;$GIT_BRANCH&quot;; then<br>        log &quot;ERROR&quot; &quot;代码拉取失败&quot;<br>        send_deploy_email &quot;failure&quot; &quot;代码拉取失败&quot; &quot;无法从$&#123;GIT_BRANCH&#125;分支拉取代码&quot;<br>        return 1<br>    fi<br>    <br>    # 构建镜像<br>    log &quot;INFO&quot; &quot;构建Docker镜像...&quot;<br>    if ! docker build --no-cache -t &quot;$&#123;IMAGE_NAME&#125;:$&#123;IMAGE_TAG&#125;&quot; .; then<br>        log &quot;ERROR&quot; &quot;镜像构建失败&quot;<br>        send_deploy_email &quot;failure&quot; &quot;镜像构建失败&quot; &quot;Docker镜像构建失败，请检查Dockerfile&quot;<br>        return 1<br>    fi<br>    <br>    # 启动新容器<br>    if ! start_new_container_temp_port; then<br>        log &quot;ERROR&quot; &quot;新容器启动失败&quot;<br>        send_deploy_email &quot;failure&quot; &quot;容器启动失败&quot; &quot;无法启动新容器&quot;<br>        return 1<br>    fi<br>    <br>    # 等待新容器就绪<br>    if ! wait_for_new_container_temp; then<br>        log &quot;ERROR&quot; &quot;新容器健康检查失败&quot;<br>        docker stop &quot;$CONTAINER_NEW_NAME&quot; 2&gt;/dev/null<br>        docker rm &quot;$CONTAINER_NEW_NAME&quot; 2&gt;/dev/null<br>        send_deploy_email &quot;failure&quot; &quot;健康检查失败&quot; &quot;新容器在$&#123;MAX_STARTUP_WAIT&#125;秒内未通过健康检查&quot;<br>        return 1<br>    fi<br>    <br>    # 执行热切换<br>    if ! perform_hot_swap_with_ports; then<br>        log &quot;ERROR&quot; &quot;热切换失败&quot;<br>        send_deploy_email &quot;failure&quot; &quot;热切换失败&quot; &quot;端口切换过程中出错&quot;<br>        return 1<br>    fi<br>    <br>    # 部署成功<br>    set_stage &quot;阶段5：部署完成&quot;<br>    <br>    local success_message=&quot;✅ 热更新部署成功完成\n\n项目: $&#123;PROJECT_NAME&#125;\n服务中断时间: &lt;30秒\n最终端口: $&#123;STANDARD_WEB_PORT&#125; (Web), $&#123;STANDARD_WS_PORT&#125; (WebSocket)\n数据库连接: 正常\n应用状态: 运行中&quot;<br>    <br>    echo &quot;&quot;<br>    echo &quot;✅ 部署成功完成！&quot;<br>    echo &quot;   应用已运行在端口: $&#123;STANDARD_WEB_PORT&#125;&quot;<br>    echo &quot;   可通过 http://$(hostname -I | awk &#x27;&#123;print $1&#125;&#x27;):$&#123;STANDARD_WEB_PORT&#125; 访问&quot;<br>    echo &quot;&quot;<br>    <br>    send_deploy_email &quot;success&quot; &quot;成功&quot; &quot;$success_message&quot;<br>    <br>    return 0<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">异常处理</span><br>handle_error() &#123;<br>    local error_line=&quot;$&#123;BASH_LINENO[0]&#125;&quot;<br>    local error_code=$?<br>    <br>    log &quot;ERROR&quot; &quot;部署失败于第$&#123;error_line&#125;行 (退出码: $&#123;error_code&#125;)&quot;<br>    <br>    # 清理临时容器<br>    docker stop &quot;$CONTAINER_NEW_NAME&quot; 2&gt;/dev/null<br>    docker rm &quot;$CONTAINER_NEW_NAME&quot; 2&gt;/dev/null<br>    <br>    # 尝试恢复旧服务<br>    if docker ps -a --filter &quot;name=$&#123;CONTAINER_NAME&#125;&quot; | grep -q &quot;$&#123;CONTAINER_NAME&#125;&quot;; then<br>        docker start &quot;$CONTAINER_NAME&quot; 2&gt;/dev/null<br>        log &quot;INFO&quot; &quot;已恢复旧容器服务&quot;<br>    fi<br>    <br>    echo &quot;&quot;<br>    echo &quot;❌ 部署失败！已恢复旧服务。&quot;<br>    echo &quot;   请查看日志: $&#123;LOG_FILE&#125;&quot;<br>    echo &quot;&quot;<br>    <br>    send_deploy_email &quot;failure&quot; &quot;脚本错误&quot; &quot;部署脚本在第$&#123;error_line&#125;行失败，错误码: $&#123;error_code&#125;&quot;<br>    <br>    exit $error_code<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置错误处理</span><br>trap &#x27;handle_error&#x27; ERR<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行主函数</span><br>main_deployment<br></code></pre></td></tr></table></figure>
<p>（2）没有热更新，较长时间服务的暂停</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">代码拉取 → 停止旧容器 → 构建镜像 → 启动新容器<br>整个过程服务中断<br></code></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">================================</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">基于Docker的Koa应用部署脚本</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">支持邮件通知、自动构建和容器管理</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">================================</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--------------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置区域 (请根据实际情况修改)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--------------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">项目配置</span><br>PROJECT_NAME=&quot;community-koa&quot;<br>PROJECT_PATH=&quot;/www/wwwroot/$&#123;PROJECT_NAME&#125;&quot;<br>GIT_BRANCH=&quot;main&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Docker配置</span><br>CONTAINER_NAME=&quot;web_api&quot;<br>IMAGE_NAME=&quot;web_api&quot;<br>IMAGE_TAG=&quot;1.0&quot;<br>PORT_WEB=11005          # 外部Web访问端口<br>PORT_WEBSOCKET=11007    # 外部WebSocket访问端口<br>CONTAINER_PORT_WEB=3002 # 容器内部Web端口<br>CONTAINER_PORT_WS=3003  # 容器内部WebSocket端口<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">邮件通知配置 (使用curl发送邮件)</span><br>QQ_EMAIL=&quot;您的QQ邮箱@qq.com&quot;<br>QQ_AUTH_CODE=&quot;您的QQ邮箱授权码&quot;<br>NOTIFY_EMAIL=&quot;接收通知的邮箱@example.com&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">日志配置</span><br>LOG_FILE=&quot;/var/log/deploy_$&#123;PROJECT_NAME&#125;.log&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">--------------------------------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化日志</span><br>init_log() &#123;<br>    echo &quot;========== 部署开始: $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) ==========&quot; | tee -a &quot;$LOG_FILE&quot;<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">记录日志函数</span><br>log() &#123;<br>    local level=&quot;$1&quot;<br>    local message=&quot;$2&quot;<br>    local timestamp=$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)<br>    echo &quot;[$&#123;timestamp&#125;] [$&#123;level&#125;] $&#123;message&#125;&quot; | tee -a &quot;$LOG_FILE&quot;<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">发送邮件函数 (使用curl)</span><br>send_deploy_email() &#123;<br>    local status=&quot;$1&quot;      # &quot;success&quot; 或 &quot;failure&quot;<br>    local subject=&quot;$2&quot;<br>    local message=&quot;$3&quot;<br>    <br>    # 根据状态设置主题前缀<br>    if [ &quot;$status&quot; = &quot;success&quot; ]; then<br>        email_prefix=&quot;✅&quot;<br>    else<br>        email_prefix=&quot;❌&quot;<br>    fi<br>    <br>    local full_subject=&quot;$&#123;email_prefix&#125; $&#123;PROJECT_NAME&#125;部署$&#123;subject&#125; - $(date &#x27;+%m-%d %H:%M&#x27;)&quot;<br>    <br>    # 创建邮件内容文件<br>    local mail_file=&quot;/tmp/deploy_email_$(date +%s).txt&quot;<br>    cat &gt; &quot;$mail_file&quot; &lt;&lt; EOF<br>From: $&#123;QQ_EMAIL&#125;<br>To: $&#123;NOTIFY_EMAIL&#125;<br>Subject: $&#123;full_subject&#125;<br>Date: $(date -R)<br>Content-Type: text/plain; charset=&quot;utf-8&quot;<br><br>项目名称: $&#123;PROJECT_NAME&#125;<br>部署状态: $&#123;status&#125;<br>通知时间: $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)<br>服务器信息: $(hostname) ($(curl -s ifconfig.me 2&gt;/dev/null || echo &quot;N/A&quot;))<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;message&#125;</span><br><br>===== 部署详情 =====<br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;DEPLOY_DETAILS:-<span class="hljs-string">&quot;无额外详情&quot;</span>&#125;</span><br><br>===== 最近日志 =====<br><span class="hljs-meta prompt_">$</span><span class="language-bash">(<span class="hljs-built_in">tail</span> -10 <span class="hljs-string">&quot;<span class="hljs-variable">$LOG_FILE</span>&quot;</span> 2&gt;/dev/null || <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;日志文件不存在&quot;</span>)</span><br><br>---<br>此邮件由部署系统自动发送<br>EOF<br>    <br>    # 使用curl发送邮件<br>    log &quot;INFO&quot; &quot;正在发送$&#123;status&#125;通知邮件...&quot;<br>    curl --ssl-reqd --silent \<br>        --url &#x27;smtps://smtp.qq.com:465&#x27; \<br>        --user &quot;$&#123;QQ_EMAIL&#125;:$&#123;QQ_AUTH_CODE&#125;&quot; \<br>        --mail-from &quot;$&#123;QQ_EMAIL&#125;&quot; \<br>        --mail-rcpt &quot;$&#123;NOTIFY_EMAIL&#125;&quot; \<br>        --upload-file &quot;$mail_file&quot;<br>    <br>    local curl_result=$?<br>    <br>    if [ $curl_result -eq 0 ]; then<br>        log &quot;INFO&quot; &quot;邮件发送成功&quot;<br>    else<br>        log &quot;ERROR&quot; &quot;邮件发送失败 (curl返回值: $&#123;curl_result&#125;)&quot;<br>    fi<br>    <br>    # 清理临时文件<br>    rm -f &quot;$mail_file&quot;<br>    return $curl_result<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查并进入项目目录</span><br>check_project_dir() &#123;<br>    log &quot;INFO&quot; &quot;检查项目目录: $&#123;PROJECT_PATH&#125;&quot;<br>    <br>    if [ ! -d &quot;$PROJECT_PATH&quot; ]; then<br>        log &quot;ERROR&quot; &quot;项目目录不存在: $&#123;PROJECT_PATH&#125;&quot;<br>        send_deploy_email &quot;failure&quot; &quot;目录检查失败&quot; &quot;项目目录不存在: $&#123;PROJECT_PATH&#125;&quot;<br>        return 1<br>    fi<br>    <br>    cd &quot;$PROJECT_PATH&quot; || &#123;<br>        log &quot;ERROR&quot; &quot;无法进入项目目录: $&#123;PROJECT_PATH&#125;&quot;<br>        send_deploy_email &quot;failure&quot; &quot;目录访问失败&quot; &quot;无法进入项目目录: $&#123;PROJECT_PATH&#125;&quot;<br>        return 1<br>    &#125;<br>    <br>    log &quot;INFO&quot; &quot;当前目录: $(pwd)&quot;<br>    return 0<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取最新代码</span><br>pull_latest_code() &#123;<br>    log &quot;INFO&quot; &quot;从GitHub拉取最新代码 (分支: $&#123;GIT_BRANCH&#125;)...&quot;<br>    <br>    # 检查git仓库<br>    if [ ! -d &quot;.git&quot; ]; then<br>        log &quot;ERROR&quot; &quot;当前目录不是Git仓库&quot;<br>        send_deploy_email &quot;failure&quot; &quot;Git仓库检查失败&quot; &quot;当前目录不是Git仓库&quot;<br>        return 1<br>    fi<br>    <br>    # 拉取代码<br>    git fetch origin<br>    if ! git pull origin &quot;$GIT_BRANCH&quot;; then<br>        log &quot;ERROR&quot; &quot;Git拉取失败&quot;<br>        send_deploy_email &quot;failure&quot; &quot;代码拉取失败&quot; &quot;从$&#123;GIT_BRANCH&#125;分支拉取代码失败&quot;<br>        return 1<br>    fi<br>    <br>    local latest_commit=$(git log -1 --oneline 2&gt;/dev/null || echo &quot;未知&quot;)<br>    log &quot;INFO&quot; &quot;代码拉取成功，最新提交: $&#123;latest_commit&#125;&quot;<br>    <br>    # 记录部署详情<br>    DEPLOY_DETAILS=&quot;代码分支: $&#123;GIT_BRANCH&#125;\n最新提交: $&#123;latest_commit&#125;\n拉取时间: $(date &#x27;+%H:%M:%S&#x27;)&quot;<br>    <br>    return 0<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查Docker容器状态</span><br>check_container_status() &#123;<br>    log &quot;INFO&quot; &quot;检查Docker容器状态: $&#123;CONTAINER_NAME&#125;&quot;<br>    <br>    # 检查容器是否存在<br>    if ! docker inspect &quot;$CONTAINER_NAME&quot; &gt; /dev/null 2&gt;&amp;1; then<br>        log &quot;INFO&quot; &quot;容器不存在: $&#123;CONTAINER_NAME&#125;&quot;<br>        CONTAINER_EXISTS=false<br>        CONTAINER_RUNNING=false<br>        return 0<br>    fi<br>    <br>    CONTAINER_EXISTS=true<br>    <br>    # 检查容器是否在运行<br>    if [ &quot;$(docker inspect -f &#x27;&#123;&#123;.State.Running&#125;&#125;&#x27; &quot;$CONTAINER_NAME&quot; 2&gt;/dev/null)&quot; = &quot;true&quot; ]; then<br>        log &quot;INFO&quot; &quot;容器正在运行: $&#123;CONTAINER_NAME&#125;&quot;<br>        CONTAINER_RUNNING=true<br>        <br>        # 获取容器ID<br>        CONTAINER_ID=$(docker ps -q --filter &quot;name=$&#123;CONTAINER_NAME&#125;&quot;)<br>        log &quot;INFO&quot; &quot;容器ID: $&#123;CONTAINER_ID&#125;&quot;<br>    else<br>        log &quot;INFO&quot; &quot;容器已停止: $&#123;CONTAINER_NAME&#125;&quot;<br>        CONTAINER_RUNNING=false<br>    fi<br>    <br>    return 0<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止并移除旧容器</span><br>cleanup_old_container() &#123;<br>    log &quot;INFO&quot; &quot;清理旧容器...&quot;<br>    <br>    # 停止正在运行的容器<br>    local running_containers=$(docker ps -q --filter &quot;name=$&#123;CONTAINER_NAME&#125;&quot;)<br>    if [ -n &quot;$running_containers&quot; ]; then<br>        log &quot;INFO&quot; &quot;停止运行中的容器: $&#123;running_containers&#125;&quot;<br>        docker stop $running_containers<br>    fi<br>    <br>    # 移除已停止的容器<br>    local all_containers=$(docker ps -aq --filter &quot;name=$&#123;CONTAINER_NAME&#125;&quot;)<br>    if [ -n &quot;$all_containers&quot; ]; then<br>        log &quot;INFO&quot; &quot;移除容器: $&#123;all_containers&#125;&quot;<br>        docker rm $all_containers<br>    fi<br>    <br>    # 清理未使用的镜像<br>    log &quot;INFO&quot; &quot;清理未使用的Docker资源...&quot;<br>    docker system prune -f<br>    <br>    return 0<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">构建Docker镜像</span><br>build_docker_image() &#123;<br>    log &quot;INFO&quot; &quot;构建Docker镜像: $&#123;IMAGE_NAME&#125;:$&#123;IMAGE_TAG&#125;&quot;<br>    <br>    # 检查Dockerfile<br>    if [ ! -f &quot;Dockerfile&quot; ]; then<br>        log &quot;ERROR&quot; &quot;Dockerfile不存在&quot;<br>        send_deploy_email &quot;failure&quot; &quot;Docker构建失败&quot; &quot;Dockerfile不存在&quot;<br>        return 1<br>    fi<br>    <br>    # 构建镜像<br>    if ! docker build --no-cache -t &quot;$&#123;IMAGE_NAME&#125;:$&#123;IMAGE_TAG&#125;&quot; .; then<br>        log &quot;ERROR&quot; &quot;Docker镜像构建失败&quot;<br>        send_deploy_email &quot;failure&quot; &quot;Docker构建失败&quot; &quot;镜像构建失败，请检查Dockerfile&quot;<br>        return 1<br>    fi<br>    <br>    log &quot;INFO&quot; &quot;Docker镜像构建成功: $&#123;IMAGE_NAME&#125;:$&#123;IMAGE_TAG&#125;&quot;<br>    <br>    # 记录镜像信息<br>    local image_info=$(docker images | grep &quot;$&#123;IMAGE_NAME&#125;&quot; | grep &quot;$&#123;IMAGE_TAG&#125;&quot; | head -1)<br>    DEPLOY_DETAILS=&quot;$&#123;DEPLOY_DETAILS&#125;\nDocker镜像: $&#123;image_info&#125;&quot;<br>    <br>    return 0<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行Docker容器</span><br>run_docker_container() &#123;<br>    log &quot;INFO&quot; &quot;启动Docker容器...&quot;<br>    <br>    # 检查端口是否被占用<br>    if ss -tulpn | grep -q &quot;:$&#123;PORT_WEB&#125;\s&quot;; then<br>        log &quot;WARN&quot; &quot;端口 $&#123;PORT_WEB&#125; 可能已被占用&quot;<br>    fi<br>    <br>    if ss -tulpn | grep -q &quot;:$&#123;PORT_WEBSOCKET&#125;\s&quot;; then<br>        log &quot;WARN&quot; &quot;端口 $&#123;PORT_WEBSOCKET&#125; 可能已被占用&quot;<br>    fi<br>    <br>    # 运行容器<br>    local run_cmd=&quot;docker run -d \<br>        --name $&#123;CONTAINER_NAME&#125; \<br>        -p $&#123;PORT_WEB&#125;:$&#123;CONTAINER_PORT_WEB&#125; \<br>        -p $&#123;PORT_WEBSOCKET&#125;:$&#123;CONTAINER_PORT_WS&#125; \<br>        $&#123;IMAGE_NAME&#125;:$&#123;IMAGE_TAG&#125;&quot;<br>    <br>    log &quot;INFO&quot; &quot;执行命令: $&#123;run_cmd&#125;&quot;<br>    <br>    if ! eval &quot;$run_cmd&quot;; then<br>        log &quot;ERROR&quot; &quot;容器启动失败&quot;<br>        send_deploy_email &quot;failure&quot; &quot;容器启动失败&quot; &quot;Docker容器启动失败，命令: $&#123;run_cmd&#125;&quot;<br>        return 1<br>    fi<br>    <br>    # 等待容器启动<br>    sleep 3<br>    <br>    # 验证容器运行状态<br>    if [ &quot;$(docker inspect -f &#x27;&#123;&#123;.State.Running&#125;&#125;&#x27; &quot;$CONTAINER_NAME&quot;)&quot; = &quot;true&quot; ]; then<br>        log &quot;INFO&quot; &quot;容器启动成功: $&#123;CONTAINER_NAME&#125;&quot;<br>        <br>        # 获取容器信息<br>        local container_id=$(docker ps -q --filter &quot;name=$&#123;CONTAINER_NAME&#125;&quot;)<br>        local container_ip=$(docker inspect -f &#x27;&#123;&#123;range.NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; &quot;$CONTAINER_NAME&quot;)<br>        <br>        DEPLOY_DETAILS=&quot;$&#123;DEPLOY_DETAILS&#125;\n容器状态: 运行中\n容器ID: $&#123;container_id&#125;\n内部IP: $&#123;container_ip&#125;\n映射端口: $&#123;PORT_WEB&#125;-&gt;$&#123;CONTAINER_PORT_WEB&#125;, $&#123;PORT_WEBSOCKET&#125;-&gt;$&#123;CONTAINER_PORT_WS&#125;&quot;<br>        <br>        return 0<br>    else<br>        log &quot;ERROR&quot; &quot;容器启动后未运行&quot;<br>        send_deploy_email &quot;failure&quot; &quot;容器启动异常&quot; &quot;容器$&#123;CONTAINER_NAME&#125;启动后未进入运行状态&quot;<br>        return 1<br>    fi<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">验证部署结果</span><br>verify_deployment() &#123;<br>    log &quot;INFO&quot; &quot;验证部署结果...&quot;<br>    <br>    # 检查容器是否响应<br>    local max_retries=10<br>    local retry_count=0<br>    <br>    while [ $retry_count -lt $max_retries ]; do<br>        if docker logs &quot;$CONTAINER_NAME&quot; 2&gt;&amp;1 | tail -5 | grep -q &quot;listening\|started\|running&quot;; then<br>            log &quot;INFO&quot; &quot;应用启动成功检测到&quot;<br>            break<br>        fi<br>        <br>        retry_count=$((retry_count + 1))<br>        log &quot;INFO&quot; &quot;等待应用启动... ($&#123;retry_count&#125;/$&#123;max_retries&#125;)&quot;<br>        sleep 2<br>    done<br>    <br>    # 获取容器日志<br>    local container_logs=$(docker logs &quot;$CONTAINER_NAME&quot; 2&gt;&amp;1 | tail -20)<br>    DEPLOY_DETAILS=&quot;$&#123;DEPLOY_DETAILS&#125;\n应用日志: $&#123;container_logs&#125;&quot;<br>    <br>    return 0<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">主部署流程</span><br>main_deployment() &#123;<br>    init_log<br>    <br>    log &quot;INFO&quot; &quot;开始部署项目: $&#123;PROJECT_NAME&#125;&quot;<br>    <br>    # 步骤1: 检查项目目录<br>    if ! check_project_dir; then<br>        return 1<br>    fi<br>    <br>    # 步骤2: 拉取最新代码<br>    if ! pull_latest_code; then<br>        return 1<br>    fi<br>    <br>    # 步骤3: 检查容器状态<br>    check_container_status<br>    <br>    # 步骤4: 清理旧容器<br>    if ! cleanup_old_container; then<br>        send_deploy_email &quot;failure&quot; &quot;容器清理失败&quot; &quot;清理旧Docker容器时出错&quot;<br>        return 1<br>    fi<br>    <br>    # 步骤5: 构建Docker镜像<br>    if ! build_docker_image; then<br>        return 1<br>    fi<br>    <br>    # 步骤6: 运行Docker容器<br>    if ! run_docker_container; then<br>        return 1<br>    fi<br>    <br>    # 步骤7: 验证部署<br>    verify_deployment<br>    <br>    # 步骤8: 发送成功通知<br>    local success_message=&quot;✅ 部署成功完成\n\n项目: $&#123;PROJECT_NAME&#125;\n时间: $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)\n状态: 所有步骤执行成功\n\n访问地址:\n- Web: http://服务器IP:$&#123;PORT_WEB&#125;\n- WebSocket: ws://服务器IP:$&#123;PORT_WEBSOCKET&#125;&quot;<br>    <br>    if send_deploy_email &quot;success&quot; &quot;成功&quot; &quot;$success_message&quot;; then<br>        log &quot;INFO&quot; &quot;========== 部署成功完成: $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;) ==========&quot;<br>        echo &quot;✅ 部署成功完成!&quot;<br>        echo &quot;   项目: $&#123;PROJECT_NAME&#125;&quot;<br>        echo &quot;   容器: $&#123;CONTAINER_NAME&#125;&quot;<br>        echo &quot;   端口: $&#123;PORT_WEB&#125; (Web), $&#123;PORT_WEBSOCKET&#125; (WebSocket)&quot;<br>        echo &quot;   时间: $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)&quot;<br>    else<br>        log &quot;WARN&quot; &quot;部署成功但邮件通知发送失败&quot;<br>        echo &quot;⚠️  部署成功，但邮件通知发送失败&quot;<br>    fi<br>    <br>    return 0<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">异常处理</span><br>handle_error() &#123;<br>    local error_code=$?<br>    local error_message=&quot;部署过程在第$&#123;BASH_LINENO[0]&#125;行发生错误 (退出码: $&#123;error_code&#125;)&quot;<br>    <br>    log &quot;ERROR&quot; &quot;$error_message&quot;<br>    <br>    # 发送失败邮件<br>    local failure_message=&quot;❌ 部署失败\n\n项目: $&#123;PROJECT_NAME&#125;\n时间: $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)\n错误: $&#123;error_message&#125;\n\n请查看服务器日志: $&#123;LOG_FILE&#125;&quot;<br>    <br>    send_deploy_email &quot;failure&quot; &quot;失败&quot; &quot;$failure_message&quot;<br>    <br>    echo &quot;❌ 部署失败!&quot;<br>    echo &quot;   错误详情请查看: $&#123;LOG_FILE&#125;&quot;<br>    exit $error_code<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置错误处理</span><br>trap handle_error ERR<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行主函数</span><br>main_deployment<br></code></pre></td></tr></table></figure>
<p><strong>普通 Node 项目做法</strong></p>
<p>（2）创建部署脚本 /www/deploy/deploy-server.sh，用 pm2 即可访问后端服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 进入项目目录</span><br>cd /www/wwwroot/mysite-express || exit<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 拉取最新代码</span><br>echo &quot;Pulling latest code from GitHub...&quot;<br>git pull origin main<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 安装依赖</span><br>npm install<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4. 重启PM2应用</span><br>pm2 restart server<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">5. 保存PM2状态</span><br>pm2 save<br><br>echo &quot;Deploy finished at $(date)&quot;<br><br></code></pre></td></tr></table></figure>
<p>pm2部署成功发送邮件的做法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deploy_with_email.sh</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">========== 配置 ==========</span><br>CONFIG_QQ_EMAIL=&quot;您的QQ邮箱@qq.com&quot;<br>CONFIG_QQ_AUTH_CODE=&quot;您的QQ邮箱授权码&quot;<br>CONFIG_TO_EMAIL=&quot;接收通知的邮箱@example.com&quot;<br>PROJECT_NAME=&quot;mysite-express&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">==========================</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">邮件发送函数</span><br>send_deploy_email() &#123;<br>    local status=$1  # 0=成功, 1=失败<br>    local message=&quot;$2&quot;<br>    <br>    if [ $status -eq 0 ]; then<br>        subject=&quot;✅ $&#123;PROJECT_NAME&#125;部署成功 - $(date &#x27;+%m-%d %H:%M&#x27;)&quot;<br>    else<br>        subject=&quot;❌ $&#123;PROJECT_NAME&#125;部署失败 - $(date &#x27;+%m-%d %H:%M&#x27;)&quot;<br>    fi<br>    <br>    # 创建邮件内容<br>    cat &gt; /tmp/deploy_email.txt &lt;&lt; EOF<br>From: $&#123;CONFIG_QQ_EMAIL&#125;<br>To: $&#123;CONFIG_TO_EMAIL&#125;<br>Subject: $&#123;subject&#125;<br>Date: $(date -R)<br><br>项目: $&#123;PROJECT_NAME&#125;<br>时间: $(date)<br>服务器: $(hostname)<br>状态: $&#123;subject%% *&#125;<br><br><br>--- 自动发送 ---<br>EOF<br>    <br>    # 发送邮件<br>    curl --ssl-reqd --silent \<br>      --url &#x27;smtps://smtp.qq.com:465&#x27; \<br>      --user &quot;$&#123;CONFIG_QQ_EMAIL&#125;:$&#123;CONFIG_QQ_AUTH_CODE&#125;&quot; \<br>      --mail-from &quot;$&#123;CONFIG_QQ_EMAIL&#125;&quot; \<br>      --mail-rcpt &quot;$&#123;CONFIG_TO_EMAIL&#125;&quot; \<br>      --upload-file /tmp/deploy_email.txt<br>    <br>    rm -f /tmp/deploy_email.txt<br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">主部署流程</span><br>main() &#123;<br>    echo &quot;开始部署...&quot;<br>    <br>    # 原有部署步骤<br>    cd /www/wwwroot/mysite-express || &#123;<br>        send_deploy_email 1 &quot;无法进入目录 /www/wwwroot/mysite-express&quot;<br>        exit 1<br>    &#125;<br>    <br>    <br>    if ! git pull origin main; then<br>        send_deploy_email 1 &quot;Git拉取失败&quot;<br>        exit 1<br>    fi<br><br>    if ! npm install; then<br>        send_deploy_email 1 &quot;npm安装失败&quot;<br>        exit 1<br>    fi<br><br>    if ! npm run build; then<br>        send_deploy_email 1 &quot;构建失败&quot;<br>        exit 1<br>    fi<br><br>    if ! pm2 restart server; then<br>        send_deploy_email 1 &quot;PM2重启失败&quot;<br>        exit 1<br>    fi<br><br>    pm2 save<br><br>     # 发送成功通知<br>    send_deploy_email 0 &quot;所有步骤执行成功&quot;<br>    echo &quot;部署完成于 $(date)&quot;<br>    <br>&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行</span><br>main<br><br></code></pre></td></tr></table></figure>
<h3 id="3、创建-webhook-接收服务（Node-示例）"><a href="#3、创建-webhook-接收服务（Node-示例）" class="headerlink" title="3、创建 webhook 接收服务（Node 示例）"></a>3、创建 webhook 接收服务（Node 示例）</h3><p>安装依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /www/webhook &amp;&amp; <span class="hljs-built_in">cd</span> /www/webhook<br>npm init -y<br>npm install express body-parser<br></code></pre></td></tr></table></figure>
<p>创建 index.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; exec &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">json</span>());<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/webhook&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Git 推送事件已接收&#x27;</span>);<br>    <span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;sh /www/deploy/deploy.sh&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, stdout, stderr</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;执行失败&#x27;</span>, stderr);<br>            <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br>        &#125;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;部署成功&#x27;</span>, stdout);<br>        res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;部署成功&#x27;</span>);<br>    &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">4000</span>, <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Webhook 服务已运行，端口 4000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>在阿里云后台安全组中的入方向一定要放开 4000 的端口</strong><br>启动服务（建议用 pm2 保活）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install -g pm2<br>pm2 start index.js --name webhook<br></code></pre></td></tr></table></figure>
<p>对于 Docker 镜像运行的项目，在创建 webhook 时，由于构建镜像需要时间，所以要提前给 github 返回状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; exec &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(bodyParser.<span class="hljs-title function_">json</span>());<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/webhook-comkoa&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Git 推送事件已接收&#x27;</span>);<br>    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;已接收，正在后台部署中...&#x27;</span>);<br>    <span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;sh /www/deploy/deploy-comkoa.sh&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, stdout, stderr</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (err) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;执行失败&#x27;</span>, stderr);<br>            <span class="hljs-keyword">return</span>;<br>            <span class="hljs-comment">// return res.status(500).send(&#x27;error&#x27;)</span><br>        &#125;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;部署成功&#x27;</span>, stdout);<br>        <span class="hljs-comment">// res.send(&#x27;后台部署成功&#x27;)</span><br>    &#125;);<br>&#125;);<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">4006</span>, <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Webhook 服务已运行，端口 4006&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h3 id="4、在-GitHub-Gitee-中配置-Webhook"><a href="#4、在-GitHub-Gitee-中配置-Webhook" class="headerlink" title="4、在 GitHub/Gitee 中配置 Webhook"></a>4、在 GitHub/Gitee 中配置 Webhook</h3><p>前往仓库设置：</p>
<ol>
<li>找到具体项目，进入 Settings &gt; Webhooks &gt; Add Webhook。</li>
<li>Payload URL: http://你的服务器公网 IP:4000/webhook（注意公网可访问）</li>
<li>Content type: application/json</li>
<li>Secret: （可选，用于校验）</li>
<li>事件类型：只选 push</li>
<li>保存</li>
</ol>
<h2 id="四、申请免费证书文件"><a href="#四、申请免费证书文件" class="headerlink" title="四、申请免费证书文件"></a>四、申请免费证书文件</h2><p>参考文档：<a target="_blank" rel="noopener" href="https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E">acme.sh</a></p>
<h3 id="1、安装-acme-sh"><a href="#1、安装-acme-sh" class="headerlink" title="1、安装 acme.sh"></a>1、安装 acme.sh</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">curl https://get.acme.sh | sh -s email=my@example.com<br></code></pre></td></tr></table></figure>
<p>安装成功后重新登录终端，或者执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>
<p>确认是否安装成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">acme.sh --version<br></code></pre></td></tr></table></figure>
<h3 id="2、使用-DSAPI-的方式"><a href="#2、使用-DSAPI-的方式" class="headerlink" title="2、使用 DSAPI 的方式"></a>2、使用 DSAPI 的方式</h3><p>打开链接：<a target="_blank" rel="noopener" href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi">dsnpi</a><br>在这个页面中找到 Aliyun，在阿里云后台创建子用户，获取到 Ali_Key 和 Ali_Secret，然后到控制台输入下面两条命令</p>
<p>步骤一：进入阿里云 RAM 控制台</p>
<p> 登录阿里云后台 <a target="_blank" rel="noopener" href="https://ram.console.aliyun.com/users">RAM 控制台</a></p>
<p> 左侧点击 用户 → 创建用户</p>
<p>步骤二：创建子用户</p>
<p> 选择 普通用户（RAM 用户）</p>
<p> 填写用户名（随便，比如 acme-cert-user，https 等）</p>
<p> 勾选 AccessKey 访问（AccessKey 方式）</p>
<p> 不要选控制台访问，否则多余</p>
<p> 点击 确认。</p>
<p>步骤三：给用户授权</p>
<p> 创建完成后，进入刚建好的用户详情页</p>
<p> 找到 权限管理 → 添加权限</p>
<p> 搜索 AliyunDNSFullAccess</p>
<p> 勾选该策略，点击 确定</p>
<p> 这样，这个用户就有了对阿里云 DNS 服务的完全操作权限。</p>
<p>步骤四：生成 AccessKey</p>
<p> 在用户详情页 → 安全设置 → AccessKey 管理</p>
<p> 点击 创建 AccessKey</p>
<p> 系统会生成 AccessKeyId 和 AccessKeySecret</p>
<p> 记得保存下来，Secret 只会显示一次。</p>
<p>步骤五：在服务器配置环境变量</p>
<p> 在你的阿里云服务器终端执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> Ali_Key=<span class="hljs-string">&quot;&lt;key&gt;&quot;</span><br><span class="hljs-built_in">export</span> Ali_Secret=<span class="hljs-string">&quot;&lt;secret&gt;&quot;</span><br></code></pre></td></tr></table></figure>
<p>为了长期生效，可以写入 ~/.bashrc：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export Ali_Key=&quot;你的AccessKeyId&quot;&#x27;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export Ali_Secret=&quot;你的AccessKeySecret&quot;&#x27;</span> &gt;&gt; ~/.bashrc<br><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>
<p>切换 CA：使用 Let’s Encrypt 替代 ZeroSSL</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">acme.sh --set-default-ca --server letsencrypt<br></code></pre></td></tr></table></figure>
<p>步骤六：测试</p>
<p> 执行以下命令测试申请证书：</p>
<p> 然后执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">acme.sh --issue --dns dns_ali -d zzf.net.cn -d *.zzf.net.cn<br></code></pre></td></tr></table></figure>
<p> 如果执行命令报错可能没注册账号，执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">acme.sh --register-account -m your@email.com<br></code></pre></td></tr></table></figure>
<p>如果配置正确，acme.sh 会自动在<a target="_blank" rel="noopener" href="https://dnsnext.console.aliyun.com/authoritative">阿里云 DNS</a> 里添加 _acme-challenge.zzf.net.cn 这种 TXT 记录，并通过验证，最终生成证书。</p>
<p>🚀 到这一步，你的 acme.sh + 阿里云 DNS 自动化申请 SSL 证书就可以跑通了。</p>
<p>如果生成的证书文件不在 nginx 配置中的路径时，需要执行以下命令，才能确保 acme 自动续期后的文件自动同步到对应的文件夹下，如果 nginx 配置的路径直接指向 acme 的目录文件，则不需要执行以下的操作<br>nginx：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">acme.sh --install-cert -d yourdomain.com \<br>--key-file /etc/nginx/ssl/yourdomain.key \<br>--fullchain-file /etc/nginx/ssl/yourdomain.cer \<br>--reloadcmd &quot;systemctl reload nginx&quot;<br></code></pre></td></tr></table></figure>
<p>宝塔面板用户</p>
<p>宝塔一般存放证书的路径是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">/www/server/panel/vhost/cert/yourdomain.com/<br></code></pre></td></tr></table></figure>
<p>可以这样安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">acme.sh --install-cert -d yourdomain.com \<br>--key-file /www/server/panel/vhost/cert/yourdomain.com/privkey.pem \<br>--fullchain-file /www/server/panel/vhost/cert/yourdomain.com/fullchain.pem \<br>--reloadcmd &quot;bt reload&quot;<br></code></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">acme.sh --install-cert -d zzf.net.cn \<br>--key-file /www/server/panel/vhost/cert/zzf.net.cn/privkey.pem \<br>--fullchain-file /www/server/panel/vhost/cert/zzf.net.cn/fullchain.pem \<br>--reloadcmd &quot;bt reload&quot;<br></code></pre></td></tr></table></figure>
  
    <div class="footer">
<script src="//m.servedby-buysellads.com/monetization.js" type="text/javascript"></script>
<div id="bsa-native"></div>
<script>
_bsa.init('custom', 'CKYD62QM', 'placement:vuejsorg',
  {
    target: '#bsa-native',
    template: '<a class="native-box" href="##statlink##"><div class="native-sponsor">Sponsor</div><div class="native-text"><strong>##company##</strong> — ##description##</div></a>'
  }
);
</script>

发现错误？想参与编辑？
        <a
            href="https://github.com/vuejs/v2.cn.vuejs.org/blob/master/src/website/process/index.md"
            rel="noopener"
            target="_blank"
        >
            在 GitHub 上编辑此页！
        </a>
        <!-- Deployed on
    <a href="https://url.netlify.com/HJ8X2mxP8" rel="noopener" target="_blank">
      Netlify
    </a>. -->
    </div>
</div>

      </div>
      <script src="/js/smooth-scroll.min.js"></script>
    

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="/js/css.escape.js"></script>
    <script src="/js/common.js"></script>

    <!-- search -->
    <link href="//code.bdstatic.com/npm/docsearch.js@1.5.0/dist/cdn/docsearch.min.css" rel='stylesheet' type='text/css'>
    
<link rel="stylesheet" href="/css/search.css">

    <script src="//code.bdstatic.com/npm/docsearch.js@1.5.0/dist/cdn/docsearch.min.js"></script>
    <script>
    [
      '#search-query-nav',
      '#search-query-sidebar',
      '#search-query-menu'
    ].forEach(function (selector) {
      if (!document.querySelector(selector)) return
      docsearch({
        appId: 'UURH1MHAF7',
        apiKey: 'c23eb8e7895f42daeaf2bf6f63eb4bf6',
        indexName: 'vuejs_cn2',
        inputSelector: selector,
        algoliaOptions: { facetFilters: ["version:v2"]},
        autocompleteOptions: { hint: false, appendTo: 'body'}
      })
    })

    // unregister service worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then(function(registrations) {
        for(let registration of registrations) {
          registration.unregister()
        }
      })
    }
    </script>
  </body>
</html>
